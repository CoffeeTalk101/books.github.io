<html><head><meta content="text/html;charset=utf-8" http-equiv="Content-Type"><title>CSY's Blog</title><style>html{font-size:24px;background-color:#f3f3f3}h1{font-size:2em;margin-top:30px;}.container-div{margin:0 auto;margin-bottom:4em}@media(min-width:576px){html{font-size:30px;}.container-div{width:95%;}}@media(min-width:768px){html{font-size:30px;}.container-div{width:95%;}}@media(min-width:992px){html{font-size:20px;}.container-div{width:70%;}}@media(min-width:1200px){html{font-size:16px;}.container-div{width:70%;}}.link-div{background-color:white;color:black;margin-top:15px;margin-bottom:15px;margin-left:20px;margin-bottom:20px;border-radius:5px;box-shadow:1px 1px 5px 0 rgba(0,0,0,0.02), 1px 1px 15px 0 rgba(0,0,0,0.03);transition:transform 0.3s, background-color 0.3s, box-shadow 0.6s;transition-property:transform, background-color, box-shadow;transition-duration:0.3s, 0.3s, 0.6s;transition-timing-function:ease, ease, ease;transition-delay:0s, 0s, 0s;padding:10px;}.link-div:hover{transform: translateY(-5px);box-shadow: 1px 10px 30px 0 rgba(0,0,0,0.2);}a{text-decoration:none;opacity: 0;}a:link,a:visited{text-decoration:none;}.headline{font-size:1.3em;font-weight: 450;line-height: 1.125;color:black;}.date{font-size:0.8em;color:gray;}.preview{color:#50596c}</style></head><body><div class="container-div"><h1>CSY's Blog</h1><a href="Text/Section0006.xhtml"><div class="link-div"><p class="headline">递归、尾递归 in Scala</p><p class="preview">首先说一个小知识点：在Scala中，递归函数的返回值类型是必须指定的（而其它函数则不必，当然从代码风格的角度，全都写明会更加清楚）。因为编译器会尝试从函数的右侧表达式找这个函数的返回值，但是对递归函数，它会找到这个函数本身，导致返回值无法确定。</p><p class="date">2020-12-08</p></div></a><a href="Text/Section0005.xhtml"><div class="link-div"><p class="headline">AI项目规划中值得考虑的非技术因素</p><p class="preview">最近组队参加了一个创新比赛，期间有专家的一对一辅导。感受比较深的就是，因为我们做的是一个人工智能相关、偏技术的产品，对技术架构和实现关注得较多，而忽略了一些必须要考虑的非技术因素。</p><p class="date">2020-12-04</p></div></a><a href="Text/Section0004.xhtml"><div class="link-div"><p class="headline">快速了解Python Type Hint</p><p class="preview">Python 作为一个动态类型语言，虽然给我们编写代码带来了很多方便，但是动态类型也会容易导致一些隐蔽的bug，一旦出现问题，通常需要较多的精力进行排查。 Python type hint 将类似于静态语言的类型提示引入代码中，可以帮助我们在编码的早期发现潜在的问题。</p><p class="date">2020-11-25</p></div></a><a href="Text/Section0003.xhtml"><div class="link-div"><p class="headline">Scala和Java混合开发和编译</p><p class="preview">Flink和Spark这类大数据库中有大量的源码是用Scala编写的，我们对这些库进行二次开发、构建定制化的版本，需要对其中的Scala代码进行编译。</p><p class="date">2020-11-17</p></div></a><a href="Text/Section0001.xhtml"><div class="link-div"><p class="headline">调整正负样本比对模型评估指标的影响</p><p class="preview">最近在Kaggle上看到了这样一个kernel，解决的问题和我们的业务类似，也是做信用卡欺诈检测。在这个kernel的标题上注明了，它的模型可以达到95%准确率。</p><p class="date">2020-10-30</p></div></a><a href="Text/Section0007.xhtml"><div class="link-div"><p class="headline">XGBoost 简介（2）</p><p class="preview">XGBoost是于2015年由陈天奇等人提出的一个新的Gradient Boosting的实现。名称中的X代表 Extreme，意思是XGBoost旨在将Gradient Boosting对资源的利用和计算能力推至极限。</p><p class="date">2020-12-09</p></div></a><a href="Text/Section0002.xhtml"><div class="link-div"><p class="headline">XGBoost 简介（1）</p><p class="preview">XGBoost是目前近年来在各类机器学习竞赛中非常热门的一个模型，在Kaggle上是公认的高分算法，在工业界也有广泛的使用。XGBoost最大的特点在于对性能的提升，例如在向模型中添加决策树时，XGBoost可以利用多核CPU计算，而传统的Bosting算法的实现则是逐一排队添加；XGBoost还优化了数据的存储结构，提高了查找的效率和硬盘吞吐率。相比于sklearn内置的Gradient Boosting的实现，XGBoost的性能常常可以提升十倍以上。</p><p class="date">2020-09-25</p></div></a></div></body></html>